{"version":3,"file":"echarts-liquidfill.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;ACVA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;;;;ACtBwC;AACxC;AACA,mCAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,yBAAyB,wBAAc;AACvC;AACA,SAAS;AACT,uBAAuB,sBAAY;AACnC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AC7EM;AACA;AACA;AACP;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;ACvE4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,IAAI;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,IAAI;AACL;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mBAAmB,WAAW;AAC9B;AACP;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACiB;AACV;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACkB;AACZ;AACP;AACA;AACO;AACP;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACA;;;;AC5hBP;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,QAAe;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACO;AACP,YAAY,MAAa;AACzB;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,sBAAsB,GAAU;AAChC;AACA,GAAG;AACH;AACA,cAAc,GAAU;AACxB;AACA;AACA,GAAG;AACH,mBAAmB,MAAa;AAChC;AACA,GAAG;AACH,kBAAkB,GAAU;AAC5B;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,GAAU;AACnB;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA,wBAAwB,EAAE,aAAa,IAAI,aAAa,IAAI,YAAY,IAAI,SAAS,IAAI,SAAS,IAAI,oDAAoD;AAC1J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI,SAAS,QAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kCAAkC;AAC1C,QAAQ,0CAA0C;AAClD,QAAQ,oCAAoC;AAC5C,QAAQ,mCAAmC;AAC3C,QAAQ,mCAAmC;AAC3C,QAAQ,oCAAoC;AAC5C,QAAQ;AACR;AACA,QAAQ,0CAA0C;AAClD,QAAQ,oCAAoC;AAC5C,QAAQ,mCAAmC;AAC3C,QAAQ,kCAAkC;AAC1C,QAAQ,mCAAmC;AAC3C,QAAQ;AACR;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,yBAAyB,QAAe;AACxC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACljBwC;AACxC;AACA,sDAAe,yBAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,EAAC;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClKwC;AACc;AACV;AAC5C;AACA,IAAI,2BAAY,GAAG,YAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA,iCAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2BAAY;AAC7C;AACA;AACA;AACA;AACA,iBAAiB,2BAAY;AAC7B,iBAAiB,2BAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2BAAY;AAC5B,gBAAgB,2BAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAAY;AACvC;AACA,4BAA4B,2BAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAe;AAC/B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAe;AAC/B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,oBAAoB,yBAAe;AACnC;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAe;AACnC;AACA,qBAAqB,iBAAiB,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yBAAe,6BAA6B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yBAAe;AAC1C;AACA,0BAA0B;AAC1B,4BAA4B,yBAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAc;AACzC;AACA;AACA;AACA,uBAAuB,yBAAe;AACtC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAAY;AACxC;AACA,6BAA6B,2BAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wBAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,wBAAc;AAC1D;AACA,sCAAsC,yBAAe;AACrD,qCAAqC,yBAAe;AACpD;AACA;AACA;AACA,kCAAkC,yBAAe;AACjD,iCAAiC,yBAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yBAAe;AAC1C;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;;AC1f2B;;;ACAF","sources":["webpack://echarts-liquidfill/webpack/universalModuleDefinition","webpack://echarts-liquidfill/external umd \"echarts\"","webpack://echarts-liquidfill/webpack/bootstrap","webpack://echarts-liquidfill/./src/liquidFillSeries.js","webpack://echarts-liquidfill/./node_modules/zrender/lib/core/platform.js","webpack://echarts-liquidfill/./node_modules/zrender/lib/core/util.js","webpack://echarts-liquidfill/./node_modules/echarts/lib/util/number.js","webpack://echarts-liquidfill/./src/liquidFillShape.js","webpack://echarts-liquidfill/./src/liquidFillView.js","webpack://echarts-liquidfill/./src/liquidFill.js","webpack://echarts-liquidfill/./index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"echarts\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"echarts\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"echarts-liquidfill\"] = factory(require(\"echarts\"));\n\telse\n\t\troot[\"echarts-liquidfill\"] = factory(root[\"echarts\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE_echarts_core__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE_echarts_core__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import * as echarts from 'echarts/core';\r\n\r\necharts.extendSeriesModel({\r\n\r\n    type: 'series.liquidFill',\r\n\r\n    optionUpdated: function () {\r\n        var option = this.option;\r\n        option.gridSize = Math.max(Math.floor(option.gridSize), 4);\r\n    },\r\n\r\n    getInitialData: function (option, ecModel) {\r\n        var dimensions = echarts.helper.createDimensions(option.data, {\r\n            coordDimensions: ['value']\r\n        });\r\n        var list = new echarts.List(dimensions, this);\r\n        list.initData(option.data);\r\n        return list;\r\n    },\r\n\r\n    defaultOption: {\r\n        color: ['#294D99', '#156ACF', '#1598ED', '#45BDFF'],\r\n        center: ['50%', '50%'],\r\n        radius: '50%',\r\n        amplitude: '8%',\r\n        waveLength: '80%',\r\n        phase: 'auto',\r\n        period: 'auto',\r\n        direction: 'right',\r\n        shape: 'circle',\r\n\r\n        waveAnimation: true,\r\n        animationEasing: 'linear',\r\n        animationEasingUpdate: 'linear',\r\n        animationDuration: 2000,\r\n        animationDurationUpdate: 1000,\r\n\r\n        outline: {\r\n            show: true,\r\n            borderDistance: 8,\r\n            itemStyle: {\r\n                color: 'none',\r\n                borderColor: '#294D99',\r\n                borderWidth: 8,\r\n                shadowBlur: 20,\r\n                shadowColor: 'rgba(0, 0, 0, 0.25)'\r\n            }\r\n        },\r\n\r\n        backgroundStyle: {\r\n            color: '#E3F7FF'\r\n        },\r\n\r\n        itemStyle: {\r\n            opacity: 0.95,\r\n            shadowBlur: 50,\r\n            shadowColor: 'rgba(0, 0, 0, 0.4)'\r\n        },\r\n\r\n        label: {\r\n            show: true,\r\n            color: '#294D99',\r\n            insideColor: '#fff',\r\n            fontSize: 50,\r\n            fontWeight: 'bold',\r\n\r\n            align: 'center',\r\n            baseline: 'middle',\r\n            position: 'inside'\r\n        },\r\n\r\n        emphasis: {\r\n            itemStyle: {\r\n                opacity: 0.8\r\n            }\r\n        }\r\n    }\r\n});\r\n","export var DEFAULT_FONT_SIZE = 12;\nexport var DEFAULT_FONT_FAMILY = 'sans-serif';\nexport var DEFAULT_FONT = DEFAULT_FONT_SIZE + \"px \" + DEFAULT_FONT_FAMILY;\nvar OFFSET = 20;\nvar SCALE = 100;\nvar defaultWidthMapStr = \"007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\\\\\WQb\\\\0FWLg\\\\bWb\\\\WQ\\\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\\\FFF5.5N\";\nfunction getTextWidthMap(mapStr) {\n    var map = {};\n    if (typeof JSON === 'undefined') {\n        return map;\n    }\n    for (var i = 0; i < mapStr.length; i++) {\n        var char = String.fromCharCode(i + 32);\n        var size = (mapStr.charCodeAt(i) - OFFSET) / SCALE;\n        map[char] = size;\n    }\n    return map;\n}\nexport var DEFAULT_TEXT_WIDTH_MAP = getTextWidthMap(defaultWidthMapStr);\nexport var platformApi = {\n    createCanvas: function () {\n        return typeof document !== 'undefined'\n            && document.createElement('canvas');\n    },\n    measureText: (function () {\n        var _ctx;\n        var _cachedFont;\n        return function (text, font) {\n            if (!_ctx) {\n                var canvas = platformApi.createCanvas();\n                _ctx = canvas && canvas.getContext('2d');\n            }\n            if (_ctx) {\n                if (_cachedFont !== font) {\n                    _cachedFont = _ctx.font = font || DEFAULT_FONT;\n                }\n                return _ctx.measureText(text);\n            }\n            else {\n                text = text || '';\n                font = font || DEFAULT_FONT;\n                var res = /((?:\\d+)?\\.?\\d*)px/.exec(font);\n                var fontSize = res && +res[1] || DEFAULT_FONT_SIZE;\n                var width = 0;\n                if (font.indexOf('mono') >= 0) {\n                    width = fontSize * text.length;\n                }\n                else {\n                    for (var i = 0; i < text.length; i++) {\n                        var preCalcWidth = DEFAULT_TEXT_WIDTH_MAP[text[i]];\n                        width += preCalcWidth == null ? fontSize : (preCalcWidth * fontSize);\n                    }\n                }\n                return { width: width };\n            }\n        };\n    })(),\n    loadImage: function (src, onload, onerror) {\n        var image = new Image();\n        image.onload = onload;\n        image.onerror = onerror;\n        image.src = src;\n        return image;\n    }\n};\nexport function setPlatformAPI(newPlatformApis) {\n    for (var key in platformApi) {\n        if (newPlatformApis[key]) {\n            platformApi[key] = newPlatformApis[key];\n        }\n    }\n}\n","import { platformApi } from './platform.js';\nvar BUILTIN_OBJECT = reduce([\n    'Function',\n    'RegExp',\n    'Date',\n    'Error',\n    'CanvasGradient',\n    'CanvasPattern',\n    'Image',\n    'Canvas'\n], function (obj, val) {\n    obj['[object ' + val + ']'] = true;\n    return obj;\n}, {});\nvar TYPED_ARRAY = reduce([\n    'Int8',\n    'Uint8',\n    'Uint8Clamped',\n    'Int16',\n    'Uint16',\n    'Int32',\n    'Uint32',\n    'Float32',\n    'Float64'\n], function (obj, val) {\n    obj['[object ' + val + 'Array]'] = true;\n    return obj;\n}, {});\nvar objToString = Object.prototype.toString;\nvar arrayProto = Array.prototype;\nvar nativeForEach = arrayProto.forEach;\nvar nativeFilter = arrayProto.filter;\nvar nativeSlice = arrayProto.slice;\nvar nativeMap = arrayProto.map;\nvar ctorFunction = function () { }.constructor;\nvar protoFunction = ctorFunction ? ctorFunction.prototype : null;\nvar protoKey = '__proto__';\nvar idStart = 0x0907;\nexport function guid() {\n    return idStart++;\n}\nexport function logError() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (typeof console !== 'undefined') {\n        console.error.apply(console, args);\n    }\n}\nexport function clone(source) {\n    if (source == null || typeof source !== 'object') {\n        return source;\n    }\n    var result = source;\n    var typeStr = objToString.call(source);\n    if (typeStr === '[object Array]') {\n        if (!isPrimitive(source)) {\n            result = [];\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n    }\n    else if (TYPED_ARRAY[typeStr]) {\n        if (!isPrimitive(source)) {\n            var Ctor = source.constructor;\n            if (Ctor.from) {\n                result = Ctor.from(source);\n            }\n            else {\n                result = new Ctor(source.length);\n                for (var i = 0, len = source.length; i < len; i++) {\n                    result[i] = source[i];\n                }\n            }\n        }\n    }\n    else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n        result = {};\n        for (var key in source) {\n            if (source.hasOwnProperty(key) && key !== protoKey) {\n                result[key] = clone(source[key]);\n            }\n        }\n    }\n    return result;\n}\nexport function merge(target, source, overwrite) {\n    if (!isObject(source) || !isObject(target)) {\n        return overwrite ? clone(source) : target;\n    }\n    for (var key in source) {\n        if (source.hasOwnProperty(key) && key !== protoKey) {\n            var targetProp = target[key];\n            var sourceProp = source[key];\n            if (isObject(sourceProp)\n                && isObject(targetProp)\n                && !isArray(sourceProp)\n                && !isArray(targetProp)\n                && !isDom(sourceProp)\n                && !isDom(targetProp)\n                && !isBuiltInObject(sourceProp)\n                && !isBuiltInObject(targetProp)\n                && !isPrimitive(sourceProp)\n                && !isPrimitive(targetProp)) {\n                merge(targetProp, sourceProp, overwrite);\n            }\n            else if (overwrite || !(key in target)) {\n                target[key] = clone(source[key]);\n            }\n        }\n    }\n    return target;\n}\nexport function mergeAll(targetAndSources, overwrite) {\n    var result = targetAndSources[0];\n    for (var i = 1, len = targetAndSources.length; i < len; i++) {\n        result = merge(result, targetAndSources[i], overwrite);\n    }\n    return result;\n}\nexport function extend(target, source) {\n    if (Object.assign) {\n        Object.assign(target, source);\n    }\n    else {\n        for (var key in source) {\n            if (source.hasOwnProperty(key) && key !== protoKey) {\n                target[key] = source[key];\n            }\n        }\n    }\n    return target;\n}\nexport function defaults(target, source, overlay) {\n    var keysArr = keys(source);\n    for (var i = 0, len = keysArr.length; i < len; i++) {\n        var key = keysArr[i];\n        if ((overlay ? source[key] != null : target[key] == null)) {\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nexport var createCanvas = platformApi.createCanvas;\nexport function indexOf(array, value) {\n    if (array) {\n        if (array.indexOf) {\n            return array.indexOf(value);\n        }\n        for (var i = 0, len = array.length; i < len; i++) {\n            if (array[i] === value) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\nexport function inherits(clazz, baseClazz) {\n    var clazzPrototype = clazz.prototype;\n    function F() { }\n    F.prototype = baseClazz.prototype;\n    clazz.prototype = new F();\n    for (var prop in clazzPrototype) {\n        if (clazzPrototype.hasOwnProperty(prop)) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n    }\n    clazz.prototype.constructor = clazz;\n    clazz.superClass = baseClazz;\n}\nexport function mixin(target, source, override) {\n    target = 'prototype' in target ? target.prototype : target;\n    source = 'prototype' in source ? source.prototype : source;\n    if (Object.getOwnPropertyNames) {\n        var keyList = Object.getOwnPropertyNames(source);\n        for (var i = 0; i < keyList.length; i++) {\n            var key = keyList[i];\n            if (key !== 'constructor') {\n                if ((override ? source[key] != null : target[key] == null)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n    }\n    else {\n        defaults(target, source, override);\n    }\n}\nexport function isArrayLike(data) {\n    if (!data) {\n        return false;\n    }\n    if (typeof data === 'string') {\n        return false;\n    }\n    return typeof data.length === 'number';\n}\nexport function each(arr, cb, context) {\n    if (!(arr && cb)) {\n        return;\n    }\n    if (arr.forEach && arr.forEach === nativeForEach) {\n        arr.forEach(cb, context);\n    }\n    else if (arr.length === +arr.length) {\n        for (var i = 0, len = arr.length; i < len; i++) {\n            cb.call(context, arr[i], i, arr);\n        }\n    }\n    else {\n        for (var key in arr) {\n            if (arr.hasOwnProperty(key)) {\n                cb.call(context, arr[key], key, arr);\n            }\n        }\n    }\n}\nexport function map(arr, cb, context) {\n    if (!arr) {\n        return [];\n    }\n    if (!cb) {\n        return slice(arr);\n    }\n    if (arr.map && arr.map === nativeMap) {\n        return arr.map(cb, context);\n    }\n    else {\n        var result = [];\n        for (var i = 0, len = arr.length; i < len; i++) {\n            result.push(cb.call(context, arr[i], i, arr));\n        }\n        return result;\n    }\n}\nexport function reduce(arr, cb, memo, context) {\n    if (!(arr && cb)) {\n        return;\n    }\n    for (var i = 0, len = arr.length; i < len; i++) {\n        memo = cb.call(context, memo, arr[i], i, arr);\n    }\n    return memo;\n}\nexport function filter(arr, cb, context) {\n    if (!arr) {\n        return [];\n    }\n    if (!cb) {\n        return slice(arr);\n    }\n    if (arr.filter && arr.filter === nativeFilter) {\n        return arr.filter(cb, context);\n    }\n    else {\n        var result = [];\n        for (var i = 0, len = arr.length; i < len; i++) {\n            if (cb.call(context, arr[i], i, arr)) {\n                result.push(arr[i]);\n            }\n        }\n        return result;\n    }\n}\nexport function find(arr, cb, context) {\n    if (!(arr && cb)) {\n        return;\n    }\n    for (var i = 0, len = arr.length; i < len; i++) {\n        if (cb.call(context, arr[i], i, arr)) {\n            return arr[i];\n        }\n    }\n}\nexport function keys(obj) {\n    if (!obj) {\n        return [];\n    }\n    if (Object.keys) {\n        return Object.keys(obj);\n    }\n    var keyList = [];\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            keyList.push(key);\n        }\n    }\n    return keyList;\n}\nfunction bindPolyfill(func, context) {\n    var args = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        args[_i - 2] = arguments[_i];\n    }\n    return function () {\n        return func.apply(context, args.concat(nativeSlice.call(arguments)));\n    };\n}\nexport var bind = (protoFunction && isFunction(protoFunction.bind))\n    ? protoFunction.call.bind(protoFunction.bind)\n    : bindPolyfill;\nfunction curry(func) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    return function () {\n        return func.apply(this, args.concat(nativeSlice.call(arguments)));\n    };\n}\nexport { curry };\nexport function isArray(value) {\n    if (Array.isArray) {\n        return Array.isArray(value);\n    }\n    return objToString.call(value) === '[object Array]';\n}\nexport function isFunction(value) {\n    return typeof value === 'function';\n}\nexport function isString(value) {\n    return typeof value === 'string';\n}\nexport function isStringSafe(value) {\n    return objToString.call(value) === '[object String]';\n}\nexport function isNumber(value) {\n    return typeof value === 'number';\n}\nexport function isObject(value) {\n    var type = typeof value;\n    return type === 'function' || (!!value && type === 'object');\n}\nexport function isBuiltInObject(value) {\n    return !!BUILTIN_OBJECT[objToString.call(value)];\n}\nexport function isTypedArray(value) {\n    return !!TYPED_ARRAY[objToString.call(value)];\n}\nexport function isDom(value) {\n    return typeof value === 'object'\n        && typeof value.nodeType === 'number'\n        && typeof value.ownerDocument === 'object';\n}\nexport function isGradientObject(value) {\n    return value.colorStops != null;\n}\nexport function isImagePatternObject(value) {\n    return value.image != null;\n}\nexport function isRegExp(value) {\n    return objToString.call(value) === '[object RegExp]';\n}\nexport function eqNaN(value) {\n    return value !== value;\n}\nexport function retrieve() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    for (var i = 0, len = args.length; i < len; i++) {\n        if (args[i] != null) {\n            return args[i];\n        }\n    }\n}\nexport function retrieve2(value0, value1) {\n    return value0 != null\n        ? value0\n        : value1;\n}\nexport function retrieve3(value0, value1, value2) {\n    return value0 != null\n        ? value0\n        : value1 != null\n            ? value1\n            : value2;\n}\nexport function slice(arr) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    return nativeSlice.apply(arr, args);\n}\nexport function normalizeCssArray(val) {\n    if (typeof (val) === 'number') {\n        return [val, val, val, val];\n    }\n    var len = val.length;\n    if (len === 2) {\n        return [val[0], val[1], val[0], val[1]];\n    }\n    else if (len === 3) {\n        return [val[0], val[1], val[2], val[1]];\n    }\n    return val;\n}\nexport function assert(condition, message) {\n    if (!condition) {\n        throw new Error(message);\n    }\n}\nexport function trim(str) {\n    if (str == null) {\n        return null;\n    }\n    else if (typeof str.trim === 'function') {\n        return str.trim();\n    }\n    else {\n        return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n    }\n}\nvar primitiveKey = '__ec_primitive__';\nexport function setAsPrimitive(obj) {\n    obj[primitiveKey] = true;\n}\nexport function isPrimitive(obj) {\n    return obj[primitiveKey];\n}\nvar MapPolyfill = (function () {\n    function MapPolyfill() {\n        this.data = {};\n    }\n    MapPolyfill.prototype[\"delete\"] = function (key) {\n        var existed = this.has(key);\n        if (existed) {\n            delete this.data[key];\n        }\n        return existed;\n    };\n    MapPolyfill.prototype.has = function (key) {\n        return this.data.hasOwnProperty(key);\n    };\n    MapPolyfill.prototype.get = function (key) {\n        return this.data[key];\n    };\n    MapPolyfill.prototype.set = function (key, value) {\n        this.data[key] = value;\n        return this;\n    };\n    MapPolyfill.prototype.keys = function () {\n        return keys(this.data);\n    };\n    MapPolyfill.prototype.forEach = function (callback) {\n        var data = this.data;\n        for (var key in data) {\n            if (data.hasOwnProperty(key)) {\n                callback(data[key], key);\n            }\n        }\n    };\n    return MapPolyfill;\n}());\nvar isNativeMapSupported = typeof Map === 'function';\nfunction maybeNativeMap() {\n    return (isNativeMapSupported ? new Map() : new MapPolyfill());\n}\nvar HashMap = (function () {\n    function HashMap(obj) {\n        var isArr = isArray(obj);\n        this.data = maybeNativeMap();\n        var thisMap = this;\n        (obj instanceof HashMap)\n            ? obj.each(visit)\n            : (obj && each(obj, visit));\n        function visit(value, key) {\n            isArr ? thisMap.set(value, key) : thisMap.set(key, value);\n        }\n    }\n    HashMap.prototype.hasKey = function (key) {\n        return this.data.has(key);\n    };\n    HashMap.prototype.get = function (key) {\n        return this.data.get(key);\n    };\n    HashMap.prototype.set = function (key, value) {\n        this.data.set(key, value);\n        return value;\n    };\n    HashMap.prototype.each = function (cb, context) {\n        this.data.forEach(function (value, key) {\n            cb.call(context, value, key);\n        });\n    };\n    HashMap.prototype.keys = function () {\n        var keys = this.data.keys();\n        return isNativeMapSupported\n            ? Array.from(keys)\n            : keys;\n    };\n    HashMap.prototype.removeKey = function (key) {\n        this.data[\"delete\"](key);\n    };\n    return HashMap;\n}());\nexport { HashMap };\nexport function createHashMap(obj) {\n    return new HashMap(obj);\n}\nexport function concatArray(a, b) {\n    var newArray = new a.constructor(a.length + b.length);\n    for (var i = 0; i < a.length; i++) {\n        newArray[i] = a[i];\n    }\n    var offset = a.length;\n    for (var i = 0; i < b.length; i++) {\n        newArray[i + offset] = b[i];\n    }\n    return newArray;\n}\nexport function createObject(proto, properties) {\n    var obj;\n    if (Object.create) {\n        obj = Object.create(proto);\n    }\n    else {\n        var StyleCtor = function () { };\n        StyleCtor.prototype = proto;\n        obj = new StyleCtor();\n    }\n    if (properties) {\n        extend(obj, properties);\n    }\n    return obj;\n}\nexport function disableUserSelect(dom) {\n    var domStyle = dom.style;\n    domStyle.webkitUserSelect = 'none';\n    domStyle.userSelect = 'none';\n    domStyle.webkitTapHighlightColor = 'rgba(0,0,0,0)';\n    domStyle['-webkit-touch-callout'] = 'none';\n}\nexport function hasOwn(own, prop) {\n    return own.hasOwnProperty(prop);\n}\nexport function noop() { }\nexport var RADIAN_TO_DEGREE = 180 / Math.PI;\n","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/*\r\n* A third-party license is embedded for some of the code in this file:\r\n* The method \"quantile\" was copied from \"d3.js\".\r\n* (See more details in the comment of the method below.)\r\n* The use of the source code of this file is also subject to the terms\r\n* and consitions of the license of \"d3.js\" (BSD-3Clause, see\r\n* </licenses/LICENSE-d3>).\r\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nvar RADIAN_EPSILON = 1e-4;\n// Although chrome already enlarge this number to 100 for `toFixed`, but\n// we sill follow the spec for compatibility.\nvar ROUND_SUPPORTED_PRECISION_MAX = 20;\nfunction _trim(str) {\n  return str.replace(/^\\s+|\\s+$/g, '');\n}\n/**\r\n * Linear mapping a value from domain to range\r\n * @param  val\r\n * @param  domain Domain extent domain[0] can be bigger than domain[1]\r\n * @param  range  Range extent range[0] can be bigger than range[1]\r\n * @param  clamp Default to be false\r\n */\nexport function linearMap(val, domain, range, clamp) {\n  var d0 = domain[0];\n  var d1 = domain[1];\n  var r0 = range[0];\n  var r1 = range[1];\n  var subDomain = d1 - d0;\n  var subRange = r1 - r0;\n  if (subDomain === 0) {\n    return subRange === 0 ? r0 : (r0 + r1) / 2;\n  }\n  // Avoid accuracy problem in edge, such as\n  // 146.39 - 62.83 === 83.55999999999999.\n  // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n  // It is a little verbose for efficiency considering this method\n  // is a hotspot.\n  if (clamp) {\n    if (subDomain > 0) {\n      if (val <= d0) {\n        return r0;\n      } else if (val >= d1) {\n        return r1;\n      }\n    } else {\n      if (val >= d0) {\n        return r0;\n      } else if (val <= d1) {\n        return r1;\n      }\n    }\n  } else {\n    if (val === d0) {\n      return r0;\n    }\n    if (val === d1) {\n      return r1;\n    }\n  }\n  return (val - d0) / subDomain * subRange + r0;\n}\n/**\r\n * Convert a percent string to absolute number.\r\n * Returns NaN if percent is not a valid string or number\r\n */\nexport function parsePercent(percent, all) {\n  switch (percent) {\n    case 'center':\n    case 'middle':\n      percent = '50%';\n      break;\n    case 'left':\n    case 'top':\n      percent = '0%';\n      break;\n    case 'right':\n    case 'bottom':\n      percent = '100%';\n      break;\n  }\n  if (zrUtil.isString(percent)) {\n    if (_trim(percent).match(/%$/)) {\n      return parseFloat(percent) / 100 * all;\n    }\n    return parseFloat(percent);\n  }\n  return percent == null ? NaN : +percent;\n}\nexport function round(x, precision, returnStr) {\n  if (precision == null) {\n    precision = 10;\n  }\n  // Avoid range error\n  precision = Math.min(Math.max(0, precision), ROUND_SUPPORTED_PRECISION_MAX);\n  // PENDING: 1.005.toFixed(2) is '1.00' rather than '1.01'\n  x = (+x).toFixed(precision);\n  return returnStr ? x : +x;\n}\n/**\r\n * Inplacd asc sort arr.\r\n * The input arr will be modified.\r\n */\nexport function asc(arr) {\n  arr.sort(function (a, b) {\n    return a - b;\n  });\n  return arr;\n}\n/**\r\n * Get precision.\r\n */\nexport function getPrecision(val) {\n  val = +val;\n  if (isNaN(val)) {\n    return 0;\n  }\n  // It is much faster than methods converting number to string as follows\n  //      let tmp = val.toString();\n  //      return tmp.length - 1 - tmp.indexOf('.');\n  // especially when precision is low\n  // Notice:\n  // (1) If the loop count is over about 20, it is slower than `getPrecisionSafe`.\n  //     (see https://jsbench.me/2vkpcekkvw/1)\n  // (2) If the val is less than for example 1e-15, the result may be incorrect.\n  //     (see test/ut/spec/util/number.test.ts `getPrecision_equal_random`)\n  if (val > 1e-14) {\n    var e = 1;\n    for (var i = 0; i < 15; i++, e *= 10) {\n      if (Math.round(val * e) / e === val) {\n        return i;\n      }\n    }\n  }\n  return getPrecisionSafe(val);\n}\n/**\r\n * Get precision with slow but safe method\r\n */\nexport function getPrecisionSafe(val) {\n  // toLowerCase for: '3.4E-12'\n  var str = val.toString().toLowerCase();\n  // Consider scientific notation: '3.4e-12' '3.4e+12'\n  var eIndex = str.indexOf('e');\n  var exp = eIndex > 0 ? +str.slice(eIndex + 1) : 0;\n  var significandPartLen = eIndex > 0 ? eIndex : str.length;\n  var dotIndex = str.indexOf('.');\n  var decimalPartLen = dotIndex < 0 ? 0 : significandPartLen - 1 - dotIndex;\n  return Math.max(0, decimalPartLen - exp);\n}\n/**\r\n * Minimal dicernible data precisioin according to a single pixel.\r\n */\nexport function getPixelPrecision(dataExtent, pixelExtent) {\n  var log = Math.log;\n  var LN10 = Math.LN10;\n  var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n  var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n  // toFixed() digits argument must be between 0 and 20.\n  var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n  return !isFinite(precision) ? 20 : precision;\n}\n/**\r\n * Get a data of given precision, assuring the sum of percentages\r\n * in valueList is 1.\r\n * The largest remainder method is used.\r\n * https://en.wikipedia.org/wiki/Largest_remainder_method\r\n *\r\n * @param valueList a list of all data\r\n * @param idx index of the data to be processed in valueList\r\n * @param precision integer number showing digits of precision\r\n * @return percent ranging from 0 to 100\r\n */\nexport function getPercentWithPrecision(valueList, idx, precision) {\n  if (!valueList[idx]) {\n    return 0;\n  }\n  var seats = getPercentSeats(valueList, precision);\n  return seats[idx] || 0;\n}\n/**\r\n * Get a data of given precision, assuring the sum of percentages\r\n * in valueList is 1.\r\n * The largest remainder method is used.\r\n * https://en.wikipedia.org/wiki/Largest_remainder_method\r\n *\r\n * @param valueList a list of all data\r\n * @param precision integer number showing digits of precision\r\n * @return {Array<number>}\r\n */\nexport function getPercentSeats(valueList, precision) {\n  var sum = zrUtil.reduce(valueList, function (acc, val) {\n    return acc + (isNaN(val) ? 0 : val);\n  }, 0);\n  if (sum === 0) {\n    return [];\n  }\n  var digits = Math.pow(10, precision);\n  var votesPerQuota = zrUtil.map(valueList, function (val) {\n    return (isNaN(val) ? 0 : val) / sum * digits * 100;\n  });\n  var targetSeats = digits * 100;\n  var seats = zrUtil.map(votesPerQuota, function (votes) {\n    // Assign automatic seats.\n    return Math.floor(votes);\n  });\n  var currentSum = zrUtil.reduce(seats, function (acc, val) {\n    return acc + val;\n  }, 0);\n  var remainder = zrUtil.map(votesPerQuota, function (votes, idx) {\n    return votes - seats[idx];\n  });\n  // Has remainding votes.\n  while (currentSum < targetSeats) {\n    // Find next largest remainder.\n    var max = Number.NEGATIVE_INFINITY;\n    var maxId = null;\n    for (var i = 0, len = remainder.length; i < len; ++i) {\n      if (remainder[i] > max) {\n        max = remainder[i];\n        maxId = i;\n      }\n    }\n    // Add a vote to max remainder.\n    ++seats[maxId];\n    remainder[maxId] = 0;\n    ++currentSum;\n  }\n  return zrUtil.map(seats, function (seat) {\n    return seat / digits;\n  });\n}\n/**\r\n * Solve the floating point adding problem like 0.1 + 0.2 === 0.30000000000000004\r\n * See <http://0.30000000000000004.com/>\r\n */\nexport function addSafe(val0, val1) {\n  var maxPrecision = Math.max(getPrecision(val0), getPrecision(val1));\n  // const multiplier = Math.pow(10, maxPrecision);\n  // return (Math.round(val0 * multiplier) + Math.round(val1 * multiplier)) / multiplier;\n  var sum = val0 + val1;\n  // // PENDING: support more?\n  return maxPrecision > ROUND_SUPPORTED_PRECISION_MAX ? sum : round(sum, maxPrecision);\n}\n// Number.MAX_SAFE_INTEGER, ie do not support.\nexport var MAX_SAFE_INTEGER = 9007199254740991;\n/**\r\n * To 0 - 2 * PI, considering negative radian.\r\n */\nexport function remRadian(radian) {\n  var pi2 = Math.PI * 2;\n  return (radian % pi2 + pi2) % pi2;\n}\n/**\r\n * @param {type} radian\r\n * @return {boolean}\r\n */\nexport function isRadianAroundZero(val) {\n  return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n}\n// eslint-disable-next-line\nvar TIME_REG = /^(?:(\\d{4})(?:[-\\/](\\d{1,2})(?:[-\\/](\\d{1,2})(?:[T ](\\d{1,2})(?::(\\d{1,2})(?::(\\d{1,2})(?:[.,](\\d+))?)?)?(Z|[\\+\\-]\\d\\d:?\\d\\d)?)?)?)?)?$/; // jshint ignore:line\n/**\r\n * @param value valid type: number | string | Date, otherwise return `new Date(NaN)`\r\n *   These values can be accepted:\r\n *   + An instance of Date, represent a time in its own time zone.\r\n *   + Or string in a subset of ISO 8601, only including:\r\n *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',\r\n *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',\r\n *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',\r\n *     all of which will be treated as local time if time zone is not specified\r\n *     (see <https://momentjs.com/>).\r\n *   + Or other string format, including (all of which will be treated as local time):\r\n *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',\r\n *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'\r\n *   + a timestamp, which represent a time in UTC.\r\n * @return date Never be null/undefined. If invalid, return `new Date(NaN)`.\r\n */\nexport function parseDate(value) {\n  if (value instanceof Date) {\n    return value;\n  } else if (zrUtil.isString(value)) {\n    // Different browsers parse date in different way, so we parse it manually.\n    // Some other issues:\n    // new Date('1970-01-01') is UTC,\n    // new Date('1970/01/01') and new Date('1970-1-01') is local.\n    // See issue #3623\n    var match = TIME_REG.exec(value);\n    if (!match) {\n      // return Invalid Date.\n      return new Date(NaN);\n    }\n    // Use local time when no timezone offset is specified.\n    if (!match[8]) {\n      // match[n] can only be string or undefined.\n      // But take care of '12' + 1 => '121'.\n      return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0);\n    }\n    // Timezoneoffset of Javascript Date has considered DST (Daylight Saving Time,\n    // https://tc39.github.io/ecma262/#sec-daylight-saving-time-adjustment).\n    // For example, system timezone is set as \"Time Zone: America/Toronto\",\n    // then these code will get different result:\n    // `new Date(1478411999999).getTimezoneOffset();  // get 240`\n    // `new Date(1478412000000).getTimezoneOffset();  // get 300`\n    // So we should not use `new Date`, but use `Date.UTC`.\n    else {\n      var hour = +match[4] || 0;\n      if (match[8].toUpperCase() !== 'Z') {\n        hour -= +match[8].slice(0, 3);\n      }\n      return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0));\n    }\n  } else if (value == null) {\n    return new Date(NaN);\n  }\n  return new Date(Math.round(value));\n}\n/**\r\n * Quantity of a number. e.g. 0.1, 1, 10, 100\r\n *\r\n * @param val\r\n * @return\r\n */\nexport function quantity(val) {\n  return Math.pow(10, quantityExponent(val));\n}\n/**\r\n * Exponent of the quantity of a number\r\n * e.g., 1234 equals to 1.234*10^3, so quantityExponent(1234) is 3\r\n *\r\n * @param val non-negative value\r\n * @return\r\n */\nexport function quantityExponent(val) {\n  if (val === 0) {\n    return 0;\n  }\n  var exp = Math.floor(Math.log(val) / Math.LN10);\n  /**\r\n   * exp is expected to be the rounded-down result of the base-10 log of val.\r\n   * But due to the precision loss with Math.log(val), we need to restore it\r\n   * using 10^exp to make sure we can get val back from exp. #11249\r\n   */\n  if (val / Math.pow(10, exp) >= 10) {\n    exp++;\n  }\n  return exp;\n}\n/**\r\n * find a “nice” number approximately equal to x. Round the number if round = true,\r\n * take ceiling if round = false. The primary observation is that the “nicest”\r\n * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\r\n *\r\n * See \"Nice Numbers for Graph Labels\" of Graphic Gems.\r\n *\r\n * @param  val Non-negative value.\r\n * @param  round\r\n * @return Niced number\r\n */\nexport function nice(val, round) {\n  var exponent = quantityExponent(val);\n  var exp10 = Math.pow(10, exponent);\n  var f = val / exp10; // 1 <= f < 10\n  var nf;\n  if (round) {\n    if (f < 1.5) {\n      nf = 1;\n    } else if (f < 2.5) {\n      nf = 2;\n    } else if (f < 4) {\n      nf = 3;\n    } else if (f < 7) {\n      nf = 5;\n    } else {\n      nf = 10;\n    }\n  } else {\n    if (f < 1) {\n      nf = 1;\n    } else if (f < 2) {\n      nf = 2;\n    } else if (f < 3) {\n      nf = 3;\n    } else if (f < 5) {\n      nf = 5;\n    } else {\n      nf = 10;\n    }\n  }\n  val = nf * exp10;\n  // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).\n  // 20 is the uppper bound of toFixed.\n  return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;\n}\n/**\r\n * This code was copied from \"d3.js\"\r\n * <https://github.com/d3/d3/blob/9cc9a875e636a1dcf36cc1e07bdf77e1ad6e2c74/src/arrays/quantile.js>.\r\n * See the license statement at the head of this file.\r\n * @param ascArr\r\n */\nexport function quantile(ascArr, p) {\n  var H = (ascArr.length - 1) * p + 1;\n  var h = Math.floor(H);\n  var v = +ascArr[h - 1];\n  var e = H - h;\n  return e ? v + e * (ascArr[h] - v) : v;\n}\n/**\r\n * Order intervals asc, and split them when overlap.\r\n * expect(numberUtil.reformIntervals([\r\n *     {interval: [18, 62], close: [1, 1]},\r\n *     {interval: [-Infinity, -70], close: [0, 0]},\r\n *     {interval: [-70, -26], close: [1, 1]},\r\n *     {interval: [-26, 18], close: [1, 1]},\r\n *     {interval: [62, 150], close: [1, 1]},\r\n *     {interval: [106, 150], close: [1, 1]},\r\n *     {interval: [150, Infinity], close: [0, 0]}\r\n * ])).toEqual([\r\n *     {interval: [-Infinity, -70], close: [0, 0]},\r\n *     {interval: [-70, -26], close: [1, 1]},\r\n *     {interval: [-26, 18], close: [0, 1]},\r\n *     {interval: [18, 62], close: [0, 1]},\r\n *     {interval: [62, 150], close: [0, 1]},\r\n *     {interval: [150, Infinity], close: [0, 0]}\r\n * ]);\r\n * @param list, where `close` mean open or close\r\n *        of the interval, and Infinity can be used.\r\n * @return The origin list, which has been reformed.\r\n */\nexport function reformIntervals(list) {\n  list.sort(function (a, b) {\n    return littleThan(a, b, 0) ? -1 : 1;\n  });\n  var curr = -Infinity;\n  var currClose = 1;\n  for (var i = 0; i < list.length;) {\n    var interval = list[i].interval;\n    var close_1 = list[i].close;\n    for (var lg = 0; lg < 2; lg++) {\n      if (interval[lg] <= curr) {\n        interval[lg] = curr;\n        close_1[lg] = !lg ? 1 - currClose : 1;\n      }\n      curr = interval[lg];\n      currClose = close_1[lg];\n    }\n    if (interval[0] === interval[1] && close_1[0] * close_1[1] !== 1) {\n      list.splice(i, 1);\n    } else {\n      i++;\n    }\n  }\n  return list;\n  function littleThan(a, b, lg) {\n    return a.interval[lg] < b.interval[lg] || a.interval[lg] === b.interval[lg] && (a.close[lg] - b.close[lg] === (!lg ? 1 : -1) || !lg && littleThan(a, b, 1));\n  }\n}\n/**\r\n * [Numeric is defined as]:\r\n *     `parseFloat(val) == val`\r\n * For example:\r\n * numeric:\r\n *     typeof number except NaN, '-123', '123', '2e3', '-2e3', '011', 'Infinity', Infinity,\r\n *     and they rounded by white-spaces or line-terminal like ' -123 \\n ' (see es spec)\r\n * not-numeric:\r\n *     null, undefined, [], {}, true, false, 'NaN', NaN, '123ab',\r\n *     empty string, string with only white-spaces or line-terminal (see es spec),\r\n *     0x12, '0x12', '-0x12', 012, '012', '-012',\r\n *     non-string, ...\r\n *\r\n * @test See full test cases in `test/ut/spec/util/number.js`.\r\n * @return Must be a typeof number. If not numeric, return NaN.\r\n */\nexport function numericToNumber(val) {\n  var valFloat = parseFloat(val);\n  return valFloat == val // eslint-disable-line eqeqeq\n  && (valFloat !== 0 || !zrUtil.isString(val) || val.indexOf('x') <= 0) // For case ' 0x0 '.\n  ? valFloat : NaN;\n}\n/**\r\n * Definition of \"numeric\": see `numericToNumber`.\r\n */\nexport function isNumeric(val) {\n  return !isNaN(numericToNumber(val));\n}\n/**\r\n * Use random base to prevent users hard code depending on\r\n * this auto generated marker id.\r\n * @return An positive integer.\r\n */\nexport function getRandomIdBase() {\n  return Math.round(Math.random() * 9);\n}\n/**\r\n * Get the greatest common divisor.\r\n *\r\n * @param {number} a one number\r\n * @param {number} b the other number\r\n */\nexport function getGreatestCommonDividor(a, b) {\n  if (b === 0) {\n    return a;\n  }\n  return getGreatestCommonDividor(b, a % b);\n}\n/**\r\n * Get the least common multiple.\r\n *\r\n * @param {number} a one number\r\n * @param {number} b the other number\r\n */\nexport function getLeastCommonMultiple(a, b) {\n  if (a == null) {\n    return b;\n  }\n  if (b == null) {\n    return a;\n  }\n  return a * b / getGreatestCommonDividor(a, b);\n}","import * as echarts from 'echarts/core';\r\n\r\nexport default echarts.graphic.extendShape({\r\n    type: 'ec-liquid-fill',\r\n\r\n    shape: {\r\n        waveLength: 0,\r\n        radius: 0,\r\n        radiusY: 0,\r\n        cx: 0,\r\n        cy: 0,\r\n        waterLevel: 0,\r\n        amplitude: 0,\r\n        phase: 0,\r\n        inverse: false\r\n    },\r\n\r\n    buildPath: function (ctx, shape) {\r\n        if (shape.radiusY == null) {\r\n            shape.radiusY = shape.radius;\r\n        }\r\n\r\n        /**\r\n         * We define a sine wave having 4 waves, and make sure at least 8 curves\r\n         * is drawn. Otherwise, it may cause blank area for some waves when\r\n         * wave length is large enough.\r\n         */\r\n        var curves = Math.max(\r\n            Math.ceil(2 * shape.radius / shape.waveLength * 4) * 2,\r\n            8\r\n        );\r\n\r\n        // map phase to [-Math.PI * 2, 0]\r\n        while (shape.phase < -Math.PI * 2) {\r\n            shape.phase += Math.PI * 2;\r\n        }\r\n        while (shape.phase > 0) {\r\n            shape.phase -= Math.PI * 2;\r\n        }\r\n        var phase = shape.phase / Math.PI / 2 * shape.waveLength;\r\n\r\n        var left = shape.cx - shape.radius + phase - shape.radius * 2;\r\n\r\n        /**\r\n         * top-left corner as start point\r\n         *\r\n         * draws this point\r\n         *  |\r\n         * \\|/\r\n         *  ~~~~~~~~\r\n         *  |      |\r\n         *  +------+\r\n         */\r\n        ctx.moveTo(left, shape.waterLevel);\r\n\r\n        /**\r\n         * top wave\r\n         *\r\n         * ~~~~~~~~ <- draws this sine wave\r\n         * |      |\r\n         * +------+\r\n         */\r\n        var waveRight = 0;\r\n        for (var c = 0; c < curves; ++c) {\r\n            var stage = c % 4;\r\n            var pos = getWaterPositions(c * shape.waveLength / 4, stage,\r\n                shape.waveLength, shape.amplitude);\r\n            ctx.bezierCurveTo(pos[0][0] + left, -pos[0][1] + shape.waterLevel,\r\n                pos[1][0] + left, -pos[1][1] + shape.waterLevel,\r\n                pos[2][0] + left, -pos[2][1] + shape.waterLevel);\r\n\r\n            if (c === curves - 1) {\r\n                waveRight = pos[2][0];\r\n            }\r\n        }\r\n\r\n        if (shape.inverse) {\r\n            /**\r\n             * top-right corner\r\n             *                  2. draws this line\r\n             *                          |\r\n             *                       +------+\r\n             * 3. draws this line -> |      | <- 1. draws this line\r\n             *                       ~~~~~~~~\r\n             */\r\n            ctx.lineTo(waveRight + left, shape.cy - shape.radiusY);\r\n            ctx.lineTo(left, shape.cy - shape.radiusY);\r\n            ctx.lineTo(left, shape.waterLevel);\r\n        }\r\n        else {\r\n            /**\r\n             * top-right corner\r\n             *\r\n             *                       ~~~~~~~~\r\n             * 3. draws this line -> |      | <- 1. draws this line\r\n             *                       +------+\r\n             *                          ^\r\n             *                          |\r\n             *                  2. draws this line\r\n             */\r\n            ctx.lineTo(waveRight + left, shape.cy + shape.radiusY);\r\n            ctx.lineTo(left, shape.cy + shape.radiusY);\r\n            ctx.lineTo(left, shape.waterLevel);\r\n        }\r\n\r\n        ctx.closePath();\r\n    }\r\n});\r\n\r\n\r\n\r\n/**\r\n * Using Bezier curves to fit sine wave.\r\n * There is 4 control points for each curve of wave,\r\n * which is at 1/4 wave length of the sine wave.\r\n *\r\n * The control points for a wave from (a) to (d) are a-b-c-d:\r\n *          c *----* d\r\n *     b *\r\n *       |\r\n * ... a * ..................\r\n *\r\n * whose positions are a: (0, 0), b: (0.5, 0.5), c: (1, 1), d: (PI / 2, 1)\r\n *\r\n * @param {number} x          x position of the left-most point (a)\r\n * @param {number} stage      0-3, stating which part of the wave it is\r\n * @param {number} waveLength wave length of the sine wave\r\n * @param {number} amplitude  wave amplitude\r\n */\r\nfunction getWaterPositions(x, stage, waveLength, amplitude) {\r\n    if (stage === 0) {\r\n        return [\r\n            [x + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2],\r\n            [x + 1 / 2 * waveLength / Math.PI,     amplitude],\r\n            [x + waveLength / 4,                   amplitude]\r\n        ];\r\n    }\r\n    else if (stage === 1) {\r\n        return [\r\n            [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2),\r\n            amplitude],\r\n            [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),\r\n            amplitude / 2],\r\n            [x + waveLength / 4,                   0]\r\n        ]\r\n    }\r\n    else if (stage === 2) {\r\n        return [\r\n            [x + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2],\r\n            [x + 1 / 2 * waveLength / Math.PI,     -amplitude],\r\n            [x + waveLength / 4,                   -amplitude]\r\n        ]\r\n    }\r\n    else {\r\n        return [\r\n            [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2),\r\n            -amplitude],\r\n            [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),\r\n            -amplitude / 2],\r\n            [x + waveLength / 4,                   0]\r\n        ]\r\n    }\r\n}\r\n","import * as echarts from 'echarts/core';\r\nimport * as numberUtil from 'echarts/lib/util/number';\r\nimport LiquidShape from './liquidFillShape';\r\n\r\nvar parsePercent = numberUtil.parsePercent;\r\n\r\nfunction isPathSymbol(symbol) {\r\n    return symbol && symbol.indexOf('path://') === 0\r\n}\r\n\r\necharts.extendChartView({\r\n\r\n    type: 'liquidFill',\r\n\r\n    render: function (seriesModel, ecModel, api) {\r\n        var self = this;\r\n        var group = this.group;\r\n        group.removeAll();\r\n\r\n        var data = seriesModel.getData();\r\n\r\n        var itemModel = data.getItemModel(0);\r\n\r\n        var center = itemModel.get('center');\r\n        var radius = itemModel.get('radius');\r\n\r\n        var width = api.getWidth();\r\n        var height = api.getHeight();\r\n        var size = Math.min(width, height);\r\n        // itemStyle\r\n        var outlineDistance = 0;\r\n        var outlineBorderWidth = 0;\r\n        var showOutline = seriesModel.get('outline.show');\r\n\r\n        if (showOutline) {\r\n            outlineDistance = seriesModel.get('outline.borderDistance');\r\n            outlineBorderWidth = parsePercent(\r\n                seriesModel.get('outline.itemStyle.borderWidth'), size\r\n            );\r\n        }\r\n\r\n        var cx = parsePercent(center[0], width);\r\n        var cy = parsePercent(center[1], height);\r\n\r\n        var outterRadius;\r\n        var innerRadius;\r\n        var paddingRadius;\r\n\r\n        var isFillContainer = false;\r\n\r\n        var symbol = seriesModel.get('shape');\r\n        if (symbol === 'container') {\r\n            // a shape that fully fills the container\r\n            isFillContainer = true;\r\n\r\n            outterRadius = [\r\n                width / 2,\r\n                height / 2\r\n            ];\r\n            innerRadius = [\r\n                outterRadius[0] - outlineBorderWidth / 2,\r\n                outterRadius[1] - outlineBorderWidth / 2\r\n            ];\r\n            paddingRadius = [\r\n                parsePercent(outlineDistance, width),\r\n                parsePercent(outlineDistance, height)\r\n            ];\r\n\r\n            radius = [\r\n                Math.max(innerRadius[0] - paddingRadius[0], 0),\r\n                Math.max(innerRadius[1] - paddingRadius[1], 0)\r\n            ];\r\n        }\r\n        else {\r\n            outterRadius = parsePercent(radius, size) / 2;\r\n            innerRadius = outterRadius - outlineBorderWidth / 2;\r\n            paddingRadius = parsePercent(outlineDistance, size);\r\n\r\n            radius = Math.max(innerRadius - paddingRadius, 0);\r\n        }\r\n\r\n        if (showOutline) {\r\n            var outline = getOutline();\r\n            outline.style.lineWidth = outlineBorderWidth;\r\n            group.add(getOutline());\r\n        }\r\n\r\n        var left = isFillContainer ? 0 : cx - radius;\r\n        var top = isFillContainer ? 0 : cy - radius;\r\n\r\n        var wavePath = null;\r\n\r\n        group.add(getBackground());\r\n\r\n        // each data item for a wave\r\n        var oldData = this._data;\r\n        var waves = [];\r\n        data.diff(oldData)\r\n            .add(function (idx) {\r\n                var wave = getWave(idx, false);\r\n\r\n                var waterLevel = wave.shape.waterLevel;\r\n                wave.shape.waterLevel = isFillContainer ? height / 2 : radius;\r\n                echarts.graphic.initProps(wave, {\r\n                    shape: {\r\n                        waterLevel: waterLevel\r\n                    }\r\n                }, seriesModel);\r\n\r\n                wave.z2 = 2;\r\n                setWaveAnimation(idx, wave, null);\r\n\r\n                group.add(wave);\r\n                data.setItemGraphicEl(idx, wave);\r\n                waves.push(wave);\r\n            })\r\n            .update(function (newIdx, oldIdx) {\r\n                var waveElement = oldData.getItemGraphicEl(oldIdx);\r\n\r\n                // new wave is used to calculate position, but not added\r\n                var newWave = getWave(newIdx, false, waveElement);\r\n\r\n                // changes with animation\r\n                var shape = {};\r\n                var shapeAttrs = ['amplitude', 'cx', 'cy', 'phase', 'radius', 'radiusY', 'waterLevel', 'waveLength'];\r\n                for (var i = 0; i < shapeAttrs.length; ++i) {\r\n                    var attr = shapeAttrs[i];\r\n                    if (newWave.shape.hasOwnProperty(attr)) {\r\n                        shape[attr] = newWave.shape[attr];\r\n                    }\r\n                }\r\n\r\n                var style = {};\r\n                var styleAttrs = ['fill', 'opacity', 'shadowBlur', 'shadowColor'];\r\n                for (var i = 0; i < styleAttrs.length; ++i) {\r\n                    var attr = styleAttrs[i];\r\n                    if (newWave.style.hasOwnProperty(attr)) {\r\n                        style[attr] = newWave.style[attr];\r\n                    }\r\n                }\r\n\r\n                if (isFillContainer) {\r\n                    shape.radiusY = height / 2;\r\n                }\r\n\r\n                // changes with animation\r\n                echarts.graphic.updateProps(waveElement, {\r\n                    shape: shape,\r\n                    x: newWave.x,\r\n                    y: newWave.y\r\n                }, seriesModel);\r\n\r\n                if (seriesModel.isUniversalTransitionEnabled && seriesModel.isUniversalTransitionEnabled()) {\r\n                    echarts.graphic.updateProps(waveElement, {\r\n                        style: style\r\n                    }, seriesModel);\r\n                }\r\n                else {\r\n                    waveElement.useStyle(style);\r\n                }\r\n\r\n                // instant changes\r\n                var oldWaveClipPath = waveElement.getClipPath();\r\n                var newWaveClipPath = newWave.getClipPath();\r\n\r\n                waveElement.setClipPath(newWave.getClipPath());\r\n                waveElement.shape.inverse = newWave.inverse;\r\n\r\n                if (oldWaveClipPath && newWaveClipPath\r\n                    && self._shape === symbol\r\n                    // TODO use zrender morphing to apply complex symbol animation.\r\n                    && !isPathSymbol(symbol)\r\n                ) {\r\n                    // Can be animated.\r\n                    echarts.graphic.updateProps(newWaveClipPath, {\r\n                        shape: oldWaveClipPath.shape\r\n                    }, seriesModel, { isFrom: true });\r\n                }\r\n\r\n                setWaveAnimation(newIdx, waveElement, waveElement);\r\n                group.add(waveElement);\r\n                data.setItemGraphicEl(newIdx, waveElement);\r\n                waves.push(waveElement);\r\n            })\r\n            .remove(function (idx) {\r\n                var wave = oldData.getItemGraphicEl(idx);\r\n                group.remove(wave);\r\n            })\r\n            .execute();\r\n\r\n        if (itemModel.get('label.show')) {\r\n            group.add(getText(waves));\r\n        }\r\n\r\n        this._shape = symbol;\r\n        this._data = data;\r\n\r\n        /**\r\n         * Get path for outline, background and clipping\r\n         *\r\n         * @param {number} r outter radius of shape\r\n         * @param {boolean|undefined} isForClipping if the shape is used\r\n         *                                          for clipping\r\n         */\r\n        function getPath(r, isForClipping) {\r\n            if (symbol) {\r\n                // customed symbol path\r\n                if (isPathSymbol(symbol)) {\r\n                    var path = echarts.graphic.makePath(symbol.slice(7), {});\r\n                    var bouding = path.getBoundingRect();\r\n                    var w = bouding.width;\r\n                    var h = bouding.height;\r\n                    if (w > h) {\r\n                        h = r * 2 / w * h;\r\n                        w = r * 2;\r\n                    }\r\n                    else {\r\n                        w = r * 2 / h * w;\r\n                        h = r * 2;\r\n                    }\r\n\r\n                    var left = isForClipping ? 0 : cx - w / 2;\r\n                    var top = isForClipping ? 0 : cy - h / 2;\r\n                    path = echarts.graphic.makePath(\r\n                        symbol.slice(7),\r\n                        {},\r\n                        new echarts.graphic.BoundingRect(left, top, w, h)\r\n                    );\r\n                    if (isForClipping) {\r\n                        path.x = -w / 2;\r\n                        path.y = -h / 2;\r\n                    }\r\n                    return path;\r\n                }\r\n                else if (isFillContainer) {\r\n                    // fully fill the container\r\n                    var x = isForClipping ? -r[0] : cx - r[0];\r\n                    var y = isForClipping ? -r[1] : cy - r[1];\r\n                    return echarts.helper.createSymbol(\r\n                        'rect', x, y, r[0] * 2, r[1] * 2\r\n                    );\r\n                }\r\n                else {\r\n                    var x = isForClipping ? -r : cx - r;\r\n                    var y = isForClipping ? -r : cy - r;\r\n                    if (symbol === 'pin') {\r\n                        y += r;\r\n                    }\r\n                    else if (symbol === 'arrow') {\r\n                        y -= r;\r\n                    }\r\n                    return echarts.helper.createSymbol(symbol, x, y, r * 2, r * 2);\r\n                }\r\n            }\r\n\r\n            return new echarts.graphic.Circle({\r\n                shape: {\r\n                    cx: isForClipping ? 0 : cx,\r\n                    cy: isForClipping ? 0 : cy,\r\n                    r: r\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Create outline\r\n         */\r\n        function getOutline() {\r\n            var outlinePath = getPath(outterRadius);\r\n            outlinePath.style.fill = null;\r\n\r\n            outlinePath.setStyle(seriesModel.getModel('outline.itemStyle')\r\n                .getItemStyle());\r\n\r\n            return outlinePath;\r\n        }\r\n\r\n        /**\r\n         * Create background\r\n         */\r\n        function getBackground() {\r\n            // Seperate stroke and fill, so we can use stroke to cover the alias of clipping.\r\n            var strokePath = getPath(radius);\r\n            strokePath.setStyle(seriesModel.getModel('backgroundStyle')\r\n                .getItemStyle());\r\n            strokePath.style.fill = null;\r\n\r\n            // Stroke is front of wave\r\n            strokePath.z2 = 5;\r\n\r\n            var fillPath = getPath(radius);\r\n            fillPath.setStyle(seriesModel.getModel('backgroundStyle')\r\n                .getItemStyle());\r\n            fillPath.style.stroke = null;\r\n\r\n            var group = new echarts.graphic.Group();\r\n            group.add(strokePath);\r\n            group.add(fillPath);\r\n\r\n            return group;\r\n        }\r\n\r\n        /**\r\n         * wave shape\r\n         */\r\n        function getWave(idx, isInverse, oldWave) {\r\n            var radiusX = isFillContainer ? radius[0] : radius;\r\n            var radiusY = isFillContainer ? height / 2 : radius;\r\n\r\n            var itemModel = data.getItemModel(idx);\r\n            var itemStyleModel = itemModel.getModel('itemStyle');\r\n            var phase = itemModel.get('phase');\r\n            var amplitude = parsePercent(itemModel.get('amplitude'),\r\n                radiusY * 2);\r\n            var waveLength = parsePercent(itemModel.get('waveLength'),\r\n                radiusX * 2);\r\n\r\n            var value = data.get('value', idx);\r\n            var waterLevel = radiusY - value * radiusY * 2;\r\n            phase = oldWave ? oldWave.shape.phase\r\n                : (phase === 'auto' ? idx * Math.PI / 4 : phase);\r\n            var normalStyle = itemStyleModel.getItemStyle();\r\n            if (!normalStyle.fill) {\r\n                var seriesColor = seriesModel.get('color');\r\n                var id = idx % seriesColor.length;\r\n                normalStyle.fill = seriesColor[id];\r\n            }\r\n\r\n            var x = radiusX * 2;\r\n            var wave = new LiquidShape({\r\n                shape: {\r\n                    waveLength: waveLength,\r\n                    radius: radiusX,\r\n                    radiusY: radiusY,\r\n                    cx: x,\r\n                    cy: 0,\r\n                    waterLevel: waterLevel,\r\n                    amplitude: amplitude,\r\n                    phase: phase,\r\n                    inverse: isInverse\r\n                },\r\n                style: normalStyle,\r\n                x: cx,\r\n                y: cy,\r\n            });\r\n            wave.shape._waterLevel = waterLevel;\r\n\r\n            var hoverStyle = itemModel.getModel('emphasis.itemStyle')\r\n                .getItemStyle();\r\n            hoverStyle.lineWidth = 0;\r\n\r\n            wave.ensureState('emphasis').style = hoverStyle;\r\n            echarts.helper.enableHoverEmphasis(wave);\r\n\r\n            // clip out the part outside the circle\r\n            var clip = getPath(radius, true);\r\n            // set fill for clipPath, otherwise it will not trigger hover event\r\n            clip.setStyle({\r\n                fill: 'white'\r\n            });\r\n            wave.setClipPath(clip);\r\n\r\n            return wave;\r\n        }\r\n\r\n        function setWaveAnimation(idx, wave, oldWave) {\r\n            var itemModel = data.getItemModel(idx);\r\n\r\n            var maxSpeed = itemModel.get('period');\r\n            var direction = itemModel.get('direction');\r\n\r\n            var value = data.get('value', idx);\r\n\r\n            var phase = itemModel.get('phase');\r\n            phase = oldWave ? oldWave.shape.phase\r\n                : (phase === 'auto' ? idx * Math.PI / 4 : phase);\r\n\r\n            var defaultSpeed = function (maxSpeed) {\r\n                var cnt = data.count();\r\n                return cnt === 0 ? maxSpeed : maxSpeed *\r\n                    (0.2 + (cnt - idx) / cnt * 0.8);\r\n            };\r\n            var speed = 0;\r\n            if (maxSpeed === 'auto') {\r\n                speed = defaultSpeed(5000);\r\n            }\r\n            else {\r\n                speed = typeof maxSpeed === 'function'\r\n                    ? maxSpeed(value, idx) : maxSpeed;\r\n            }\r\n\r\n            // phase for moving left/right\r\n            var phaseOffset = 0;\r\n            if (direction === 'right' || direction == null) {\r\n                phaseOffset = Math.PI;\r\n            }\r\n            else if (direction === 'left') {\r\n                phaseOffset = -Math.PI;\r\n            }\r\n            else if (direction === 'none') {\r\n                phaseOffset = 0;\r\n            }\r\n            else {\r\n                console.error('Illegal direction value for liquid fill.');\r\n            }\r\n\r\n            // wave animation of moving left/right\r\n            if (direction !== 'none' && itemModel.get('waveAnimation')) {\r\n                wave\r\n                    .animate('shape', true)\r\n                    .when(0, {\r\n                        phase: phase\r\n                    })\r\n                    .when(speed / 2, {\r\n                        phase: phaseOffset + phase\r\n                    })\r\n                    .when(speed, {\r\n                        phase: phaseOffset * 2 + phase\r\n                    })\r\n                    .during(function () {\r\n                        if (wavePath) {\r\n                            wavePath.dirty(true);\r\n                        }\r\n                    })\r\n                    .start();\r\n            }\r\n        }\r\n\r\n        /**\r\n         * text on wave\r\n         */\r\n        function getText(waves) {\r\n            var labelModel = itemModel.getModel('label');\r\n\r\n            function formatLabel() {\r\n                var formatted = seriesModel.getFormattedLabel(0, 'normal');\r\n                var defaultVal = (data.get('value', 0) * 100);\r\n                var defaultLabel = data.getName(0) || seriesModel.name;\r\n                if (!isNaN(defaultVal)) {\r\n                    defaultLabel = defaultVal.toFixed(0) + '%';\r\n                }\r\n                return formatted == null ? defaultLabel : formatted;\r\n            }\r\n\r\n            var textRectOption = {\r\n                z2: 10,\r\n                shape: {\r\n                    x: left,\r\n                    y: top,\r\n                    width: (isFillContainer ? radius[0] : radius) * 2,\r\n                    height: (isFillContainer ? radius[1] : radius) * 2\r\n                },\r\n                style: {\r\n                    fill: 'transparent'\r\n                },\r\n                textConfig: {\r\n                    position: labelModel.get('position') || 'inside'\r\n                },\r\n                silent: true\r\n            };\r\n            var textOption = {\r\n                style: {\r\n                    text: formatLabel(),\r\n                    textAlign: labelModel.get('align'),\r\n                    textVerticalAlign: labelModel.get('baseline')\r\n                }\r\n            };\r\n            Object.assign(textOption.style, echarts.helper.createTextStyle(labelModel));\r\n\r\n            var outsideTextRect = new echarts.graphic.Rect(textRectOption);\r\n            var insideTextRect = new echarts.graphic.Rect(textRectOption);\r\n            insideTextRect.disableLabelAnimation = true;\r\n            outsideTextRect.disableLabelAnimation = true;\r\n\r\n            var outsideText = new echarts.graphic.Text(textOption);\r\n            var insideText = new echarts.graphic.Text(textOption);\r\n            outsideTextRect.setTextContent(outsideText);\r\n\r\n            insideTextRect.setTextContent(insideText);\r\n            var insColor = labelModel.get('insideColor');\r\n            insideText.style.fill = insColor;\r\n\r\n            var group = new echarts.graphic.Group();\r\n            group.add(outsideTextRect);\r\n            group.add(insideTextRect);\r\n\r\n            // clip out waves for insideText\r\n            var boundingCircle = getPath(radius, true);\r\n\r\n            wavePath = new echarts.graphic.CompoundPath({\r\n                shape: {\r\n                    paths: waves\r\n                },\r\n                x: cx,\r\n                y: cy\r\n            });\r\n\r\n            wavePath.setClipPath(boundingCircle);\r\n            insideTextRect.setClipPath(wavePath);\r\n\r\n            return group;\r\n        }\r\n    },\r\n\r\n    dispose: function () {\r\n        // dispose nothing here\r\n    }\r\n});\r\n","import './liquidFillSeries';\r\nimport './liquidFillView';","import './src/liquidFill';\r\n"],"names":[],"sourceRoot":""}